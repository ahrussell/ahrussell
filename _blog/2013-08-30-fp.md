### Why Declarative Programming Matters
________________

This is a thought I've been wanting to articulate for a while.  I had always been at least somewhat aware of the benefits of functional programming, and have always tried to encorporate its style into my development process, but it was this past summer when I dove all of the way in.  As part of my work this summer I spent a good amount of time doing Android development.  This required an ugly divorce from my psuedofunctional Python style.  The legal fees cost a fortune, and my frustration with programming was at an all time high.  This was my first real experience with Java, and its insistence on making every goddamn thing defined via classes still keeps me up at night.  I tried at first.  I really did.  I would define some method or function as purely as possible.  But when it later needed to depend on some state of some object at some particular point, and I just threw in the towel and gave in to the madness.  At night, I kept my sanity by spending time with that beautiful seductress Haskell.

But I digress.  Many of the benefits of functional programming are well known:  no mutable state/purity, modularity and composition to reign in complexity, first class functions, referential transparency, and many, many others.  If you aren't familiar with FP, I really do suggest introducing yourself to it.  But be warned, she is a fickle mistress, and you might end up hating your job, your coworkers, and the code you write or maintain.

It was at a Python meetup earlier this summer when I really had my personal revelation that Functional Programming Matters<sup>tm</sup>.  I had always been in favor of FP principles, but never really got the "bottom line."  I was in a conversation with an unemployed engineer who maintained a blog on what he had learned during programming interviews.  I asked him for one of his favorite programming challenges, and he began describing an algorithm for dealing with a large data set in some context.  And as I heard him outline this process I realized that the very way we think is declarative, not imperative.  

No matter how many layers of abstractions we put on it, imperative programming is merely a wrapper around simple processor instructions.  With declarative/functional programming, we don't particularly care how something is implemented, just that we have access to that something.  For example, we don't want to spend time and energy thinking about how the maximum element of a list is found, just that we can call a function `max` and get it.  Of course, this is a bit of a trivial example, but it gives a small glimpse into the power of thinking this way.

I suspect that most or all of us already program like this.  For my own part, whenever I begin thinking and writing down a solution to a particular problem, my psuedocode/thoughts are entirely devoid of trivial details like for loops.  They just aren't important to the big picture. So although functional/declarative programming can be an alien monster for those familiar to the imperative world, it's actually more Chimpanzee than it is Martian.

Functional programming is becoming increasingly imperative (sorry, I couldn't resist) in a technical world exploding with complexity.  The closer the process of programming comes to actually resembling our own thought processes the more powerful and productive we can become.
