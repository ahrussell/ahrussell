### Why Declarative Programming Matters
________________

This was a thought I've been wanting to articulate for a while.  I had always been at least a little aware of the benefits of functional programming, and have always tried to encorporate it into my development style, but it was this past summer when I began to start actually thinking functionally.  As part of my work this summer I spent a good amount of time doing Android development.  Java's verbosity, type system, and callback hell (I learned firsthand that dealing with a lot of anonymous objects/classes can be a huge pain) drove me back to functional programming.  I sought to learn Haskell, because I already had some familiarity with Lisp and really wanted to throw myself off of the deep end.

In the process, I've learned an incredible amount and am still learning a ton as I seek to actually build something in Haskell.  But I digress.  Many of the benefits of functional programming are well known:  no mutable state/purity, modularity and composition to reign in complexity, first class functions, referential transparency, and many, many others.  But the moment when I had my personal revelation that functional programming Matters<super>tm</super> was at a Python meetup earlier this summer in San Francisco.  I was talking with an older unemployed engineer who maintained a blog on what he had learned while doing programming problems in technical interviews.  I asked him for one of his favorite programming challenges, and he began describing an algorithm for dealing with a large data set in some context (I unfortunately don't remember the specifics of the problem or the solution).  And as I heard him describe this process I realized that we think declaratively, not imperatively.  He wasn't describing the problem in terms of abstracted processor instructions.  No matter how many layers of abstractions we put on it, imperative programming comes down to wrapping this abstraction around simple processor instructions, and this is extremely limiting.  But this isn't how we reason with the world.  We don't describe an algorithm like "for each `i` where `0 <= i < n` and `n` is the length of a list `x`, take the `i`th element, and do something with it."  He was describing this particular solution in terms of phrases like "get the largest element of this list and do something with it."  This is a declarative description, not imperative.  What we care about, and what we're spending mental energy on, isn't how the the largest element is found, just that we have a way of getting it.  Compared to breaking down the problem into its specific x86 instructions, this is incredibly powerful. 

I suspect that most or all of us think this way.  For my own part, whenever I begin thinking and writing down a solution to a particular problem, my psuedocode/thoughts are entirely devoid of for loops.  Ideally, my problem solving process would start with a function call `getOutput(input)`, but I'm usually too eager to start that simply.  So although functional/declarative programming can be scary and is an alien way to program for those used to the imperative world, it's really something quite closer to home.

Functional programming is becoming increasingly imperative (sorry, I couldn't resist) in a technical world with exploding complexity.  The closer the process of programming comes to actually resembling our own thought processes the more powerful and productive we can become.
