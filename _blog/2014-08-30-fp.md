### Why Declarative Programming Matters
________________

This was a thought I've been wanting to articulate for a while.  I had always been at least a little aware of the benefits of functional programming, and have always tried to encorporate it into my development style, but it was this past summer when I began to start actually thinking functionally.  As part of my work this summer I spent a good amount of time doing Android development.  Java's verbosity, type system, and callback hell (I learned firsthand that dealing with a lot of anonymous objects/classes can be a huge pain) drove me back to functional programming.  I sought to learn Haskell, because I already had some familiarity with Lisp and really wanted to throw myself off of the deep end.

But I digress.  Many of the benefits of functional programming are well known:  no mutable state/purity, modularity and composition to reign in complexity, first class functions, referential transparency, and many, many others.  But the moment when I had my personal revelation that functional programming Matters<sup>tm</sup> was at a Python meetup earlier this summer in San Francisco.  I was talking with an unemployed engineer who maintained a blog on what he had learned during programming interviews.  I asked him for one of his favorite programming challenges, and he began describing an algorithm for dealing with a large data set in some context.  And as I heard him describe this process I realized that they very way we think is declarative, not imperative.  

No matter how many layers of abstractions we put on it, imperative programming is merely a wrapper around simple processor instructions.  With declarative/functional programming, we don't particularly care how something is implemented, just that we have access to that something.  For example, we don't want to spend time and energy thinking about how the maximum element of a list is found, just that we can call a function `max` and get it.  Of course, this is a bit of a trivial example, but it gives a small glimpse into the power of thinking this way.

I suspect that most or all of us already program like this.  For my own part, whenever I begin thinking and writing down a solution to a particular problem, my psuedocode/thoughts are entirely devoid of trivial details like for loops.  They just aren't important to the big picture. So although functional/declarative programming can be scary and is an alien way to program for those familiar to the imperative world, it's actually something quite close to home.

Functional programming is becoming increasingly imperative (sorry, I couldn't resist) in a technical world exploding with complexity.  The closer the process of programming comes to actually resembling our own thought processes the more powerful and productive we can become.
